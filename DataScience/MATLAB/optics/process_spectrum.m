function [sp] = process_spectrum(irradiance, wavelength)
% function [sp] = process_spectrum(irradiance, wavelength)
%  Function used to calculate peak irradiance, peak wavelength, total irradiance, and centroid wavelength of a given optical spectrum.
% Also calculates photocurrent per wavelength and total photocurrent
% generated by the LED.
% If you get an "Matrix dimensions must agree" error try calling instead
% sp = process_spectrum(irradiance', wavelength')
%
% Inputs
% irradiance - vector with spectral irradiances in the first dimension. May also be an MxN matrix, in which case the first dimension are
% M wavelengths and second dimension are N different spectra.
% wavelength - spectral wavelengths (1xM)
%
% Outputs
% sp - structure with spectrally-processed data, with the following fields:
%   peakIrr - peak (maximum) irradiance. Has the same units as irradiance.
%   peakWavel - peak wavelength. Has same units as wavelength.
%   totIrr - total irradiance. Has the units of irradiance multiplied by the units of wavelength.
%   cenWavel - centroid wavelength. Has the same units as wavelength.
%   fwhm - full width half max wavelength. Has same units as wavelength.
%   totPower - total power (Irradiance * Area of cosine corrector). Has the same
%       units as irradiance times cm^2.
%   currentPerWavel - photocurrent per unit wavelength. Units of Amps normalized to Watts/nm. That is, when Irradiance is in units of uW and wavelength is in units of nm, currentPerWavel has units of uA/nm uA when
%   current - total photocurrent (integrated over all wavelengths).
%   centCutt - centroid wavelength, taking photodiode spectrum into account.
%       Has the same units as wavelength.
%
% P. Silveira, June 2015
% BSX Proprietary

Area = 0.119460636961914; % = pi*(0.39/2)^2, area of cosine corrector with 6.35mm of diameter (cm^2)
R = PD_resp(wavelength); % get responsivity values (A/W)
sz = size(irradiance);
mwavel = repmat(wavelength, 1, sz(2));  % arrayed wavelength

[sp.peakIrr, peakIdx] = max(irradiance);
sp.peakWavel = wavelength(peakIdx)';  % peak (max) wavelength
sp.totIrr = trapz(wavelength, irradiance); %sum(irradiance(:,ii));    % total irradiance
sp.centWavel = sum(irradiance .* repmat(wavelength, [1, sz(2)])) ./ sum(irradiance);    % calculate centroid wavelength
%sp.centWavel = sum(irradiance .* wavelength) ./ sum(irradiance);    % calculate centroid wavelength
sp.totPower = sp.totIrr * Area;  % total optical power
sp.currentPerWavel = irradiance .* Area .* repmat(R, [1, sz(2)]);    % calculate photocurrents
%sp.currentPerWavel = irradiance .* Area .* R;    % calculate photocurrents
sp.current = trapz(wavelength, sp.currentPerWavel); %sum(sp.currentPerWavel(:,ii));    % calculate photocurrent per nm
sp.centCurr = sum(sp.currentPerWavel .* mwavel)./ sum(sp.currentPerWavel);    % calculate centroid photocurrent
%sp.centCurr = sum(sp.currentPerWavel .* wavelength)./ sum(sp.currentPerWavel);    % calculate centroid photocurrent
for ii = 1:sz(2);
    [temp, fwhm_idx1] = min(abs(irradiance(1:peakIdx(ii),ii) - sp.peakIrr(ii)/2)); % find leftmost point closest to FWHM
    [temp, fwhm_idx2] = min(abs(irradiance(peakIdx(ii):end,ii) - sp.peakIrr(ii)/2)); % find rightmost point closest to FHWM
    sp.fwhm(ii) = wavelength(peakIdx(ii)+fwhm_idx2) - wavelength(fwhm_idx1+1);    % FHWM wavelength given by wavelength difference between the two points
end

end

